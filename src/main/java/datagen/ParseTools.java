/**
 * MIT License
 * 
 * Copyright (c) 2021 Jeff Sember
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 **/
package datagen;

import static js.base.Tools.*;

import java.util.List;
import java.util.regex.Pattern;

import datagen.gen.Language;
import js.base.BasePrinter;
import js.json.JSMap;
import js.parsing.DFA;
import js.parsing.MacroParser;
import js.parsing.RegExp;
import static datagen.Utils.*;

public final class ParseTools {

  public static final boolean SHOW_STACK_TRACES = false && alert("showing full stack traces");

  public static final String EXT_DATA_DEFINITION = "dat";
  public static final String DOT_EXT_DATA_DEFINITION = "." + EXT_DATA_DEFINITION;

  // Token Ids generated by 'dev dfa' tool (DO NOT EDIT BELOW)
  public static final int WS = 0;
  public static final int STRING = 1;
  public static final int EQUALS = 2;
  public static final int ID = 3;
  public static final int NUMBER = 4;
  public static final int SEMI = 5;
  public static final int BROP = 6;
  public static final int BRCL = 7;
  public static final int SQOP = 8;
  public static final int SQCL = 9;
  public static final int COMMA = 10;
  public static final int COLON = 11;
  public static final int BOOL = 12;
  public static final int EXCLAIM = 13;
  public static final int OPTIONAL = 14;
  public static final int REPEATED = 15;
  public static final int DEPRECATION = 16;
  // End of token Ids generated by 'dev dfa' tool (DO NOT EDIT ABOVE)

  private static DFA sDFA;

  public static DFA dfa() {
    if (sDFA == null) {
      sDFA = new DFA(JSMap.fromResource(Datagen.class, "tokens.dfa"));
    }
    return sDFA;
  }

  /**
   * Reformat lines to eliminate trailing whitespace and to adjust the number of
   * blank lines
   * 
   * For Python, lines starting with \\n are interpreted as a request for n
   * blank lines (if n is omitted, it is assumed n = 1)
   */
  public static String adjustLinefeeds(String content, Language language) {
    List<String> lines = arrayList();
    int cursor = 0;
    while (cursor < content.length()) {
      int n = content.indexOf('\n', cursor);
      if (n < 0)
        n = content.length();
      String line = content.substring(cursor, n);
      // Strip any *trailing* whitespace
      lines.add(trimRight(line));
      cursor = n + 1;
    }

    StringBuilder sb = new StringBuilder();

    switch (language) {
    default:
      throw languageNotSupported();

    case JAVA:
    case GO: {
      int blanks = 1;
      for (String line : lines) {
        if (line.isEmpty()) {
          if (blanks == 0)
            addCr(sb);
          blanks++;
        } else {
          blanks = 0;
          sb.append(line);
          addCr(sb);
        }
      }
    }
      break;
    case PYTHON: {
      int blankRequest = 0;
      for (String line : lines) {
        String trimmed = line.trim();
        if (trimmed.isEmpty())
          continue;
        final String prefix = "\\\\";
        if (trimmed.startsWith(prefix)) {
          String s = ifNullOrEmpty(chompPrefix(trimmed, prefix), "1");
          blankRequest = Integer.parseInt(s);
          continue;
        }
        if (sb.length() != 0) {
          for (int i = 0; i < blankRequest; i++)
            addCr(sb);
        }
        blankRequest = 0;
        sb.append(line);
        addCr(sb);
      }
    }
      break;
    }

    return sb.toString();
  }

  public static String processOptionalComments(String content, boolean includeComments) {
    MacroParser p = new MacroParser();
    p.withPattern(RegExp.pattern("@@([^\\x0a\\x0d]*)"));
    p.withTemplate(content);
    String result = p.content((key) -> {
      if (includeComments)
        return key;
      return "";
    });
    return result;
  }

  /**
   * Wrap a class name and some source code in delimeters to the class name is
   * imported, and the source code is generated (which can be an empty string)
   */
  public static String importExprWithCode(String qualifiedClassName, String sourceCode) {
    return "{{" + qualifiedClassName + "|" + sourceCode + "}}";
  }

  public static String importExprWithClassName(QualifiedName qualifiedName) {
    // Python primitive types (e.g. int) won't have packages, so don't wrap them in import expressions
    if (qualifiedName.packagePath().isEmpty())
      return qualifiedName.className();
    return importExprWithCode(qualifiedName.combined(), qualifiedName.className());
  }

  private static String javaClassExpr(String qualifiedClassName) {
    return importedClassExpr(Language.JAVA, qualifiedClassName);
  }

  private static String pythonClassExpr(String qualifiedClassName) {
    return importedClassExpr(Language.PYTHON, qualifiedClassName);
  }

  /**
   * Wrap a class name in delimeters so the class is imported, and the class
   * name (without its package) is generated
   */
  public static String importedClassExpr(Language language, String qualifiedClassName) {
    if (language == null)
      language = language();
    try {
      QualifiedName qn = QualifiedName.parse(qualifiedClassName //
//          , null, language //
          );
      checkState(nonEmpty(qn.packagePath()));
      String className = qn.className();
      return importExprWithCode(qualifiedClassName, className);
    } catch (Throwable t) {
      throw badArg("Failed to parse imported class expression:", quote(qualifiedClassName), "for language",
          language);
    }
  }

  // Qualified class names for some of my data types (and Java's), in case they change or get substituted in future
  //
  public static final String PKG_TOOLS = javaClassExpr("js.base.Tools");
  public static final String PKG_DATAUTIL = javaClassExpr("js.data.DataUtil");
  public static final String PKG_JSMAP = javaClassExpr("js.json.JSMap");
  public static final String PKG_JSLIST = javaClassExpr("js.json.JSList");
  public static final String PKG_FILES = javaClassExpr("js.file.Files");
  public static final String PKG_LIST = javaClassExpr("java.util.List");
  public static final String PKG_MAP = javaClassExpr("java.util.Map");
  public static final String PKG_SET = javaClassExpr("java.util.Set");
  public static final String PKG_HASH_SET = javaClassExpr("java.util.HashSet");
  public static final String PKG_CONCURRENT_MAP = javaClassExpr("java.util.concurrent.ConcurrentHashMap");
  public static final String PKG_STRING = javaClassExpr("java.lang.String");
  public static final String PKG_OBJECT = javaClassExpr("java.lang.Object");
  public static final String PKG_ARRAYS = javaClassExpr("java.util.Arrays");
  public static final String PKG_ARRAYLIST = javaClassExpr("java.util.ArrayList");
  public static final String PKG_JSOBJECT = javaClassExpr("js.json.JSObject");
  public static final String PKG_MUTABLELIST = "new " + PKG_ARRAYLIST + "<>()";
  public static final String PKG_SHORT_ARRAY = javaClassExpr("js.data.ShortArray");
  public static final String PKG_FLOAT_ARRAY = javaClassExpr("js.data.FloatArray");
  public static final String PKG_DOUBLE_ARRAY = javaClassExpr("js.data.DoubleArray");

  public static final String PKGPY_DATAUTIL = pythonClassExpr("pycore.datautil.DataUtil");
  public static final String PKGPY_LIST = pythonClassExpr("typing.List");

  public static Pattern IMPORT_REGEXP = RegExp.pattern("\\{\\{([^\\}]*)\\}\\}");

  public static final String immutableCopyOfList(String expr) {
    String result = PKG_DATAUTIL + ".immutableCopyOf(" + expr + ")";
    if (Context.debugMode())
      result += debugComment();
    return result;
  }

  public static final String mutableCopyOfList(String expr) {
    checkState(!Context.generatedTypeDef.classMode());
    return PKG_DATAUTIL + ".mutableCopyOf(" + expr + ")";
  }

  public static final String mutableCopyOfMap(String expr) {
    checkState(!Context.generatedTypeDef.classMode());
    return PKG_DATAUTIL + ".mutableCopyOf(" + expr + ")";
  }

  public static final String immutableCopyOfMap(String expr) {
    String result = PKG_DATAUTIL + ".immutableCopyOf(" + expr + ")";
    if (Context.debugMode())
      result += debugComment();
    return result;
  }

  public static final String immutableCopyOfSet(String expr) {
    String result = PKG_DATAUTIL + ".immutableCopyOf(" + expr + ")";
    if (Context.debugMode())
      result += debugComment();
    return result;
  }

  public static Object assignToListExpr(String expr) {
    if (Context.generatedTypeDef.isUnsafe())
      return expr;
    return ParseTools.immutableCopyOfList(expr);
  }

  public static Object debugComment() {
    if (Context.debugMode())
      return " /*DEBUG*/ ";
    return "";
  }

  public static String notSupportedMessage(Object... messages) {
    StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
    StackTraceElement elem = stackTrace[2];

    StringBuilder sb = new StringBuilder();
    sb.append("!!!=== Not supported yet");
    if (messages.length > 0) {
      sb.append(": ");
      sb.append(BasePrinter.toString(messages));
    } else {
      sb.append("!");
    }
    sb.append(" (");
    sb.append(elem.getFileName());
    sb.append("(");
    sb.append(elem.getLineNumber());
    sb.append("): ");
    sb.append(elem.getMethodName());
    sb.append(") ===!!!");
    return sb.toString();
  }

}
