@@// ---------------------------------------------------------------------------------------
@@// This is Go code supporting the SIMULATED database operations
@@// ---------------------------------------------------------------------------------------
@@

type databaseStruct struct {
  Base         BaseObject
  Lock      sync.Mutex
  state        dbState
  dataSourceName string

  simFilesPath Path
  memTables    map[string]MemTable
}


func newDatabase() Database {
  t := &databaseStruct{}
  t.Base.SetName("Database")
  t.memTables = make(map[string]MemTable)
  return t
}

func getSimDirectoryFromSql(pth Path) Path {
  CheckArg(pth.Extension() == "db", "expected '.db' extension for path:", pth)
  return pth.SetExtension("sim")
}

func DeleteDatabase(pth Path) {
  CheckState(singletonDatabase == nil, "<1Database has already been opened")
  pth.CheckNonEmpty()
  pth2 := getSimDirectoryFromSql(pth)
  pth2.DeleteDirectoryM("_TMP_")
}


func (db Database) flushChanges() {
  for _, mt := range db.memTables {
    if mt.modified {
      mt.Base.Log("flushing")
      p := db.getSimFile(mt)
      p.WriteStringM(mt.table.CompactString())
      mt.modified = false
    }
  }
}


func (db Database) Open() {
  if !db.tryLock(dbStateNew) {
    BadState("Illegal database state")
  }
  defer db.unlock()
  db.state = dbStateOpen

  var bgndTask = func() {
    for {
      SleepMs(1000)
      db.Base.Log("flush periodically")
      if !db.tryLock(dbStateOpen) {
        db.Base.Log("...database has closed, exiting")
        return
      }
      db.flushChanges()
      db.Lock.Unlock()
    }
  }
  go bgndTask()
}

func (db Database) Close() {
  if db.tryLock(dbStateOpen) {
    defer db.unlock()
    db.flushChanges()
    db.state = dbStateClosed
  }
}

func (db Database) flushTable(mt MemTable) {
  p := db.getSimFile(mt)
  p.WriteStringM(mt.table.CompactString())
}

func (db Database) getTable(name string) MemTable {
  mt := db.memTables[name]
  if mt == nil {
    mt = NewMemTable(name)
    db.memTables[name] = mt
    p := db.getSimFile(mt)
    mt.table = JSMapFromFileIfExistsM(p)
  }
  return mt
}

func (db Database) getSimDir() Path {
  if db.simFilesPath.Empty() {
    x := NewPathM(db.dataSourceName)
    db.simFilesPath = getSimDirectoryFromSql(x)
    db.simFilesPath.MkDirsM()
  }
  return db.simFilesPath
}

func (db Database) getSimFile(m MemTable) Path {
  return db.getSimDir().JoinM(m.name + ".json")
}

type MemTableStruct struct {
  Base     BaseObject
  name     string
  table    JSMap
  modified bool
}

type MemTable = *MemTableStruct

func NewMemTable(name string) MemTable {
  t := &MemTableStruct{
    name:  name,
    table: NewJSMap(),
  }
  t.Base.SetName("MemTable(" + name + ")")
  //t.Base.AlertVerbose()
  return t
}

func (m MemTable) getValue(key string) (JSMap, bool) {
  val, ok := m.table.WrappedMap()[key]
  return val.(JSMap), ok
}

func (m MemTable) nextUniqueKey() int {
  i := 1
  for {
    if !m.table.HasKey(IntToString(i)) {
      Todo("reimplement as binary search for highest key")
      break
    }
    i++
  }
  return i
}

func (m MemTable) GetData(key any, parser DataClass) DataClass {
  strKey := argToMemtableKey(key)
  val := m.table.OptMap(strKey)
  if val == nil {
    return nil
  }

  defer CatchPanic(func() {
    Pr("Failed to parse:", INDENT, val)
  })

  return parser.Parse(val)
}

func (m MemTable) Put(key any, value any) {
  strKey := argToMemtableKey(key)
  jsmapValue := argToMemtableValue(value)
  m.Base.Log("Writing:", strKey, "=>", INDENT, jsmapValue)
  m.table.Put(strKey, jsmapValue)
}

func (m MemTable) HasKey(key any) bool {
  strKey := argToMemtableKey(key)
  return m.table.HasKey(strKey)
}

func argToMemtableKey(key any) string {
  var strKey string
  switch k := key.(type) {
  case string:
    strKey = k
  case int:
    strKey = IntToString(k)
  case int64:
    strKey = IntToString(int(k))
  case int32:
    strKey = IntToString(int(k))
  default:
    BadArg("illegal key:", key, "type:", k, "Info:", Info(key))
  }
  return strKey
}

func argToMemtableValue(val any) JSMap {
  var strKey JSMap
  switch k := val.(type) {
  case nil:
    break
  case JSMap:
    strKey = k
  default:
    {
      result, ok := val.(DataClass)
      if ok {
        strKey = result.ToJson().AsJSMap()
      }
    }
    break
  }
  if strKey == nil {
    BadArg("illegal value:", val, "type:", reflect.TypeOf(val))
  }
  return strKey
}



