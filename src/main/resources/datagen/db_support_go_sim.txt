@@// ---------------------------------------------------------------------------------------
@@// This is code supporting the SIMULATED database operations
@@// ---------------------------------------------------------------------------------------
@@

var NoSuchObjectErr = Error("No such object found")

type DatabaseStruct struct {
  Base         BaseObject
  Lock      sync.Mutex
  state        dbState
  dataSourceName string

  simFilesPath Path
  memTables    map[string]MemTable
}

type Database = *DatabaseStruct


type dbState int

const (
  dbStateNew dbState = iota
  dbStateOpen
  dbStateClosed
)

var singletonDatabase Database

func newDatabase() Database {
  t := &DatabaseStruct{}
  t.Base.SetName("Database")
  t.memTables = make(map[string]MemTable)
  return t
}

func CreateDatabase(dataSourceName string)   {
	CheckState(singletonDatabase == nil, "<1Singleton database already exists")
	singletonDatabase = newDatabase()
	singletonDatabase.dataSourceName = dataSourceName
	b := singletonDatabase.Base
	b.SetName("Database")
	b.AlertVerbose()
	singletonDatabase.Open()
}

func Db() Database {
  CheckState(singletonDatabase != nil, "<1No database created yet")
  return singletonDatabase
}

func (db Database) flushChanges() {
  for _, mt := range db.memTables {
    if mt.modified {
      mt.Base.Log("flushing")
      p := db.getSimFile(mt)
      p.WriteStringM(mt.table.CompactString())
      mt.modified = false
    }
  }
}


func (db Database) Open() {
  if !db.tryLock(dbStateNew) {
    BadState("Illegal database state")
  }
  defer db.unlock()
  db.state = dbStateOpen
// db.createTables()

  var bgndTask = func() {
    for {
      SleepMs(1000)
      db.Base.Log("flush periodically")
      if !db.tryLock(dbStateOpen) {
        db.Base.Log("...database has closed, exiting")
        return
      }
      db.flushChanges()
      db.Lock.Unlock()
    }
  }
  go bgndTask()
}

func (db Database) Close() {
  if db.tryLock(dbStateOpen) {
    defer db.unlock()
    db.flushChanges()
    db.state = dbStateClosed
  }
}

const SECONDS = 1000
const MINUTES = SECONDS * 60
const HOURS = MINUTES * 60

func (db Database) flushTable(mt MemTable) {
  p := db.getSimFile(mt)
  p.WriteStringM(mt.table.CompactString())
}

func (db Database) getTable(name string) MemTable {
  mt := db.memTables[name]
  if mt == nil {
    mt = NewMemTable(name)
    db.memTables[name] = mt
    p := db.getSimFile(mt)
    mt.table = JSMapFromFileIfExistsM(p)
  }
  return mt
}

func (db Database) getSimDir() Path {
  if db.simFilesPath.Empty() {
    db.simFilesPath = NewPathM("simulated_db")
    db.simFilesPath.MkDirsM()
  }
  return db.simFilesPath
}

func (db Database) getSimFile(m MemTable) Path {
  return db.getSimDir().JoinM(m.name + ".json")
}

type MemTableStruct struct {
  Base     BaseObject
  name     string
  table    JSMap
  modified bool
}

type MemTable = *MemTableStruct

func NewMemTable(name string) MemTable {
  t := &MemTableStruct{
    name:  name,
    table: NewJSMap(),
  }
  t.Base.SetName("MemTable(" + name + ")")
  t.Base.AlertVerbose()
  return t
}

func (m MemTable) getValue(key string) (JSMap, bool) {
  val, ok := m.table.WrappedMap()[key]
  return val.(JSMap), ok
}

func (m MemTable) nextUniqueKey() int {
  i := 1
  for {
    if !m.table.HasKey(IntToString(i)) {
      Todo("reimplement as binary search for highest key")
      break
    }
    i++
  }
  return i
}

func (m MemTable) GetData(key any, parser DataClass) DataClass {
  strKey := argToMemtableKey(key)
  val := m.table.OptMap(strKey)
  if val == nil {
    return nil
  }

  defer CatchPanic(func() {
    Pr("Failed to parse:", INDENT, val)
  })

  return parser.Parse(val)
}

func (m MemTable) Put(key any, value any) {
  strKey := argToMemtableKey(key)
  jsmapValue := argToMemtableValue(value)
  m.Base.Log("Writing:", strKey, "=>", INDENT, jsmapValue)
  m.table.Put(strKey, jsmapValue)
}

func (m MemTable) HasKey(key any) bool {
  strKey := argToMemtableKey(key)
  return m.table.HasKey(strKey)
}

func argToMemtableKey(key any) string {
  var strKey string
  switch k := key.(type) {
  case string:
    strKey = k
  case int:
    strKey = IntToString(k)
  case int64:
    strKey = IntToString(int(k))
  case int32:
    strKey = IntToString(int(k))
  default:
    BadArg("illegal key:", key, "type:", k, "Info:", Info(key))
  }
  return strKey
}

func argToMemtableValue(val any) JSMap {
  var strKey JSMap
  switch k := val.(type) {
  case nil:
    break
  case JSMap:
    strKey = k
  default:
    {
      result, ok := val.(DataClass)
      if ok {
        strKey = result.ToJson().AsJSMap()
      }
    }
    break
  }
  if strKey == nil {
    BadArg("illegal value:", val, "type:", reflect.TypeOf(val))
  }
  return strKey
}

// Acquire the lock on the database, and clear the error register.
func (db Database) lock() {
  if !db.tryLock(dbStateOpen) {
    BadState("<1Illegal state:", db.state)
  }
}

// Attempt to acquire the lock on the database; if state isn't expectedState, releases lock and returns false
func (db Database) tryLock(expectedState dbState) bool {
  db.Lock.Lock()
  if db.state != expectedState {
    db.Lock.Unlock()
    return false
  }
  //db.err = nil
  return true
}

func (db Database) unlock() {
  db.Lock.Unlock()
}


