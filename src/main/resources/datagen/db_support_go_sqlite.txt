@@// ---------------------------------------------------------------------------------------
@@// This is Go code supporting the Sqlite database operations
@@// ---------------------------------------------------------------------------------------
@@


type DatabaseStruct struct {
  Base         BaseObject
  Lock      sync.Mutex
  SqlDatabase    *sql.DB
  state        dbState
  dataSourceName string
}



func newDatabase() Database {
  t := &DatabaseStruct{}
  t.Base.SetName("Database")
  return t
}









func DeleteDatabase(pth Path) {
  CheckState(singletonDatabase == nil, "<1Database has already been opened")
  pth.CheckNonEmpty()
  baseName := pth.Base()
  if !strings.Contains(baseName,"_TMP_") {
    Alert("Not deleting database with path:",pth,INDENT,"since it is missing the substring '_TMP_'")
    return
  }
  pth.DeleteFileM()
}




func (b Database) Open() {
  Todo("the conflict between mysql db and our Database class is annoying; rename 'our' Database to b?")
  if !b.tryLock(dbStateNew) {
    BadState("Illegal database state")
  }
  defer b.unlock()
  b.state = dbStateOpen
  
  db, err := sql.Open("sqlite3", b.dataSourceName)
  if err != nil {
    BadState("Trouble opening sqlite database", INDENT, err)
  }
  b.SqlDatabase = db

[!init_code1]
[!init_code2]

}

func (db Database) Close() {
  if db.tryLock(dbStateOpen) {
    defer db.unlock()
    db.state = dbStateClosed
  }
}

// Given an array of sql.Rows containing a single id, attempt to read
// the id from the first such row.  Returns:
//    (id, nil)  a row existed, and id was successfully scanned
//    (0, nil)   no rows
//    (0, error) if some error occurred.
//
func scanIdFromRows(rows *sql.Row) (int, error) {
	var id int
	err := rows.Scan(&id)
	if err == sql.ErrNoRows {
		err = nil
	}
	return id, err
}

