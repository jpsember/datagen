@@// ---------------------------------------------------------------------------------------
@@// Generated code: DO NOT MODIFY
@@// ---------------------------------------------------------------------------------------
@@

#![allow(dead_code)]
#![allow(non_snake_case)]

[!imports]

// This is what clients see for immutable and builders
//
pub type [!class] = {{std.sync.Arc|Arc}}<dyn [!interface_name]OrBuilder>;


// ---------------------------------------------------------------------------------------
// [!interface_name] interface
// ---------------------------------------------------------------------------------------

[!deprecated]pub trait [!interface_name]OrBuilder  {
[!class_getter_declaration]
  fn build(&self) -> [!class];
  fn to_builder(&self) -> [!builder_name];
  fn to_json(&self) -> {{crate.json.*|}}JSValue;
}

// This is what clients see for builders.
// This is also what an immutable has, but it is only exposed via the immutable trait
//
#[derive(Clone)]
pub struct [!builder_name] {
[!instance_fields]}


[!class_specific]



impl [!class]OrBuilder for [!class]Builder {

[!class_getter_implementation]

  // When an immutable or builder is asked to build, it returns a fresh copy
  fn build(&self) -> [!class] {
    Arc::new(self.clone())
  }

  fn to_builder(&self) -> [!class]Builder {
      self.clone()
  }

  fn to_json(&self) -> {{crate.json.*|}}JSValue {
    let m = new_map();
[!to_json]
    m
  }

}




// ---------------------------------------------------------------------------------------
// Implementation of builder
// ---------------------------------------------------------------------------------------


impl [!class]Builder {

[!setters]
}

// This returns a freshly-constructed default instance.
// For efficiency, threads will have to construct their own copies of this as needed,
// since in Rust, we canâ€™t share these safely across different threads.
//
pub fn default_[!class]() -> [!class] {
  Arc::new([!class]Builder {
[!class_init_fields_to_defaults]
  })
}

impl {{std.fmt|fmt}}::Display for dyn [!class]OrBuilder {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{}", self.to_json().to_string())
  }
}

impl fmt::Display for [!class]Builder {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{}", self.to_json().to_string())
  }
}


// ---------------------------------------------------------------------------------------
// Global function for parsing, not tied to a particular instance
// ---------------------------------------------------------------------------------------

pub fn parse_[!class](m: {{crate.json.*|}}JSValue) -> Result<[!class], Box<dyn error::{{std.error|Error}}>> {
    let mut n = default_[!class]().to_builder();
[!parse]
    Ok(n.build())
}


