@@// ---------------------------------------------------------------------------------------
@@// Generated code: DO NOT MODIFY
@@// ---------------------------------------------------------------------------------------
@@

#![allow(dead_code)]
#![allow(non_snake_case)]


[!package_decl]
/*
imports macro not implemented:

[!imports]

*/

use crate::json::*;
use std::error;
use std::rc::Rc;

// ---------------------------------------------------------------------------------------
// [!interface_name] interface
// ---------------------------------------------------------------------------------------


// These are the functions that immutable objects
// support (they are also supported by builders)
//

[!deprecated]pub trait [!interface_name]OrBuilder  {
[!class_getter_declaration]
  fn build(&self) -> Rc<Private[!class]>;
  fn to_builder(&self) -> [!builder_name];
  fn to_json(&self) -> JSValue;
  fn parse(&self, s: JSValue) -> Result<[!class], Box<dyn error::Error>>;
}

// This is what clients see for immutable and builders
//
pub type [!class] = Rc<dyn [!interface_name]OrBuilder>;

// This is what clients see for builders.
// This is also what an immutable has, but it is only exposed
// via the immutable trait
//
#[derive(Clone)]
pub struct [!builder_name] {
    s: Private[!class],
}

// These are the fields.  They are stored for both clients and builders
//
#[derive(Clone)]
struct Private[!class] {
[!instance_fields]}


[!class_specific]



impl [!class]OrBuilder for Private[!class] {

[!class_getter_implementation]

    // When an immutable or builder is asked to build, it returns a fresh copy
    fn build(&self) -> Rc<Private[!class]> {
	    Rc::new(self.clone())
	}

    fn to_builder(&self) -> [!class]Builder {
        [!class]Builder {
            s: self.clone(),
        }
    }

  fn to_json(&self) -> JSValue {
    let m = new_map();
[!to_json]
    m
  }

  fn parse(&self, m: JSValue) -> Result<[!class], Box<dyn error::Error>> {
    let mut b = default_[!class]().to_builder();
[!parse]
    Ok(b.build())
	}

}




// ---------------------------------------------------------------------------------------
// Implementation of builder
// ---------------------------------------------------------------------------------------


impl [!class]Builder {

[!setters]



// This returns a freshly-constructed default instance.
// For efficiency, threads will have to construct their own copies of this as needed,
// since in Rust, we canâ€™t share these safely across different threads.
//
pub fn default_[!class]() -> [!class] {
  Rc::new(Private[!class] {
[!class_init_fields_to_defaults]
  })
}

